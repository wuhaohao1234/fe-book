在日常开发中几乎无时无刻不在与版本号打交道。无论是手机上的应用更新提醒，还是开发者在项目中频繁拉取的最新依赖包，版本号如影随形。我们可能常常看到诸如 `0.0.1`、`2.0.3` 这样的版本号。随着时间的推移这些数字不断迭代更新，开发者们是如何确定一个新版本号应该是多少的呢？

为了让开发者和用户明确了解软件每次更新的意义，[语义化版本控制](https://semver.org/lang/zh-CN/)（Semantic Versioning，简称 SemVer）应运而生。SemVer 是一套用于版本号管理的标准，通过使用 `MAJOR.MINOR.PATCH` 的格式，确保版本号不仅仅是随机的数字堆积，而是传达软件状态和变化信息的重要手段

## MAJOR.MINOR.PATCH
语义化版本号由三个数字部分组成，分别是主版本号（MAJOR）、次版本号（MINOR）和补丁版本号（PATCH），并以点号分隔，如 `2.1.3`。每一部分都有其特定的含义：

**主版本号（MAJOR）**：当做了不兼容的 API 修改，如删除或重命名方法、参数等。不兼容的修改会破坏现有客户端代码的运行，需要用户手动调整代码来配合新版本。

```json
### 以前的版本: 1.0.0
- 采用经典的MVC架构

### 新版本: 2.0.0
- 重构为单页应用（SPA），显著改动了架构和 API，不与过去版本兼容，因此增加主版本号
```

**次版本号（MINOR）**：当做了向下兼容的功能性新增，如新增方法、增强现有功能等。次版本号变化通常不会破坏现有客户端代码，用户可以直接升级，无需修改。

```json
### 以前的版本: 1.0.0
- 增加用户登录功能

### 新版本: 1.1.0
- 添加了购物车功能，但未对现有功能产生影响，因此增加次版本号
```

**补丁版本号（PATCH）**：当做了向下兼容的问题修正，如修复 bug、性能提升等。补丁版本号变化意味着修补了已有的缺陷，不影响现有功能的兼容性。

```json
### 以前的版本: 1.0.0
- 修复导航栏的显示问题

### 新版本: 1.0.1
- 由于修复了一个小 bug，并且与现有功能兼容，因此更新补丁版本号
```

:::info
很多开发者会简称 `x.y.z`，比如 1.2.3 x 位是 1，z 位是 3 

:::

<font style="color:rgb(51, 51, 51);">如果使用 npm 提升包的版本，可以使用 </font>`<font style="color:rgb(51, 51, 51);">npm version</font>`<font style="color:rgb(51, 51, 51);"> 命令方便地修改 </font>`<font style="color:rgb(51, 51, 51);">package.json</font>`<font style="color:rgb(51, 51, 51);"> 中的版本号，并创建相应的 Git 标签</font>

1. `**<font style="color:rgb(51, 51, 51);">npm version patch</font>**`<font style="color:rgb(51, 51, 51);">: 增加补丁版本（如从 </font>`<font style="color:rgb(51, 51, 51);">1.0.0</font>`<font style="color:rgb(51, 51, 51);"> 到 </font>`<font style="color:rgb(51, 51, 51);">1.0.1</font>`<font style="color:rgb(51, 51, 51);">）</font>
2. `**<font style="color:rgb(51, 51, 51);">npm version minor</font>**`<font style="color:rgb(51, 51, 51);">: 增加次版本（如从 </font>`<font style="color:rgb(51, 51, 51);">1.0.0</font>`<font style="color:rgb(51, 51, 51);"> 到 </font>`<font style="color:rgb(51, 51, 51);">1.1.0</font>`<font style="color:rgb(51, 51, 51);">）</font>
3. `**<font style="color:rgb(51, 51, 51);">npm version major</font>**`<font style="color:rgb(51, 51, 51);">: 增加主版本（如从 </font>`<font style="color:rgb(51, 51, 51);">1.0.0</font>`<font style="color:rgb(51, 51, 51);"> 到 </font>`<font style="color:rgb(51, 51, 51);">2.0.0</font>`<font style="color:rgb(51, 51, 51);">）</font>

## 先行版本
除了上述三部分外，语义化版本控制还支持**先行版本**（Pre-release），这些标识符可以帮助标识在正式发布前的不同阶段，如 alpha、beta、release candidate（rc），在 react npm version 中可以看到

![](https://cdn.nlark.com/yuque/0/2024/png/87727/1723883079010-3801a6b8-98a6-4046-a034-23036cd1937a.png)

先行版本号使用连字符 `-` 在主版本号、次版本号或补丁版本号后面跟一个标识符，例如：

+ 1.0.0-alpha
+ 1.0.0-beta
+ 1.0.0-rc.1

先行版本号的序列为小于其关联的正常版本号，例如：`1.0.0-alpha` < `1.0.0`

## 版本范围标识符
在 package.json 文件中除了经常会看到版本号前后有些奇奇怪怪的描述符号

```javascript
"dependencies": {
   "react": "18.x", 
    "lodash": "^4.0.0"
}
```

这些又是什么含义？

### 大小写的 “x” 或 *
+ 格式：`2.x`, `2.3.x`, `2.*`, `*`
+ 含义：`x` 或 `*` 表示任意可接受的版本
    - `2.x` 和 `2.*` 表示次版本号 `MINOR` 和补丁版本号 `PATCH` 可以是任意值
    - `2.3.x` 和 `2.3.*` 表示补丁版本号 `PATCH` 可以是任意值

### 插入符号 (^)
+ 格式：`^2.3.5`
+ 含义：匹配所有与给定版本兼容的版本
    - 对于主版本号为非零的情况（如 `^2.3.5`），它表示可以使用 2.x.x 版本中的任意版本（不低于 2.3.5 并小于 3.0.0）
    - 对于主版本号为零的情况（如 `^0.3.5`），它表示次版本号必须相同，即 `>= 0.3.5 < 0.4.0`
    - 对于仅次版本号（MINOR或PATCH）为零的情况（如 `^0.0.x`），它表示补丁版本号必须相同

### 波浪号 (~)
+ 格式：`~4.0.0`
+ 含义：它匹配指定版本的次版本号（MINOR）范围内的所有版本，允许 PATCH 版本号的变化
    - 具体地说，对于 `~4.0.0`，它匹配 `>= 4.0.0` 并且 `< 4.1.0` 的所有版本

### 范围运算符
+ 格式：`>=`, `<=`, `>`, `<`
+ 含义：
    - 指定版本的具体范围。
    - `>= 2.3.0` 表示匹配所有版本号大于或等于 `2.3.0` 的版本
    - `<= 4.0.0` 表示匹配所有版本号小于或等于 `4.0.0` 的版本

### 组合运算符
+ 格式：`>=2.3.0 <2.5.0`, `1.2.3 - 2.3.4`
+ 含义：
    - 可以使用连字符 `-` 或通过组合多个范围来指定复杂的版本范围
    - `1.2.3 - 2.3.4` 表示匹配 `>=1.2.3` 并且 `<=2.3.4` 的版本
    - `>=2.3.0 <2.5.0` 表示匹配所有版本号大于等于 `2.3.0` 并且小于 `2.5.0` 的版本

### demo
```json
{
  "dependencies": {
    "express": "^4.17.1",     // 允许 4.x 的版本
    "lodash": "~4.17.20",     // 允许 4.17.x 的版本
    "react": "17.0.2",        // 精确版本
    "webpack": ">=4.0.0 <5.0.0"  // 范围运算符
  }
}
```

## LTS 和 Major 版本奇偶数
在软件工程中，“长期支持”（Long-Term Support，简称 LTS）和“主要版本的奇偶数”（Major versions odd/even numbering）是两个常见的版本管理策略，理解这些策略可以帮助开发者和用户更有条理地规划和使用软件版本

### LTS 版本
LTS 版本有几个特征

+ 长时间支持：LTS 版本通常拥有较长的支持周期（如 2 年、3 年或更长），这使得用户可以在更长的时间内获得安全和维护更新。
+ 稳定为主：LTS 版本通常基于较为成熟且经过广泛测试的软件版本，因此它们更稳定，适合生产环境。
+ 安全修复：LTS 版本会周期性地收到安全修复和漏洞修补，即使不再接收新功能更新。

Node.js 是一个 LTS 版本管理案例。每个主要版本都会指定一个 LTS 版本，该版本在其整个生命周期内会得到持续的支持和更新。

+ 当前版本：活跃开发，可能会有频繁的新功能发布
+ LTS 版本：以稳定性为主，会定期接收安全和漏洞修复

例如，Node.js 14.x 版本是一个 LTS 版本，从 2020 年 10 月进入 LTS，计划支持到 2023 年 4 月。

```plain
版本号    | 发布日期   | 进入 LTS     | LTS 结束     | 最终结束
---------|------------|--------------|-------------|-----------
14.x     | 2020-04-21 | 2020-10-27   | 2023-04-30  | 2023-04-30
```

### 奇偶数版本策略
某些开源项目采用主要版本号的奇偶数策略来区分稳定版本和开发版本。这种策略通常如下：

+ 偶数版本（Even Numbered Major Versions）：表示稳定版本，适合在生产环境中使用，并享有较长的支持期。
+ 奇数版本（Odd Numbered Major Versions）：表示开发版本，包含最新的功能和改进，但可能不如偶数版本稳定。

这种版本管理方式提供了一种清晰的标识，帮助用户和开发者容易地分辨稳定版本和开发版本。Node.js 在其早期的版本发布策略中采用了奇偶数进行版本区分

+ 稳定版本（偶数）：如 Node.js 4.x，Node.js 6.x，Node.js 8.x，适合生产环境
+ 开发版本（奇数）：如 Node.js 5.x，Node.js 7.x，主要用于发布新特性和改进，不推荐生产环境使用

